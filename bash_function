#!/bin/bash

red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)
bold=$(tput bold)
reset=$(tput sgr0)

function line1()
{
    echo $(seq -s= 1 $(tput cols) | tr -d '[:digit:]')
}
function line2()
{
    echo $(seq -s━ 1 $(tput cols) | tr -d '[:digit:]')
}
function line3() {
    echo ${green}$(seq -s '━╸' 1 $(( $(tput cols) / 2 )) | tr -d '[:digit:]')${reset}
}

# Safe color defaults
bold=${bold:-$(tput bold 2>/dev/null || echo '')}
yellow=${yellow:-$(tput setaf 3 2>/dev/null || echo '')}
reset=${reset:-$(tput sgr0 2>/dev/null || echo '')}

function title1() {
    local str="$1"
    local len=${#str}
    local underline=""
    local i

    # Build underline
    for ((i=0; i<len; i++)); do
        underline+="="
    done

    # Print title + underline safely
    printf "\n%s\n%s\n\n" "${bold}${yellow}${str}${reset}" "${bold}${yellow}${underline}${reset}"
}



function run()
{
    echo "${green}Running: >>> ${red}$@${green} <<< ${reset}"
    echo
    "$@"
    echo
}
function run0()
{
    echo "${green}Running: >>> ${red}$@${green} <<< ${reset}"
    "$@"
}

function nullrun()
{
    bash ~/.bash/spinner "$@"

    # $@ & spinner "$@"
    # echo
    # echo -en "${green}Running: >>> ${red} $@ ${green} <<< ${reset}"
    # "$@" &> /dev/null;[ $? -eq 0 ] && echo -en ${yellow}'\r\xE2\x9C\x94\xE2\x9C\x94\xE2\x9C\x94\xE2\x9C\x94\xE2\x9C\x94\xE2\x9C\x94\xE2\x9C\x94\xE2\x9C\x94'${reset} || echo -e ${red}'\n failed \n' ${reset}
    # echo
}
function loop() {
    local interval=${1:-1}  
    if ! [[ $interval =~ ^[0-9]+$ ]]; then
        echo "Invalid interval. Setting default interval to 1 second."
        interval=0
    else
        shift
    fi

    echo
    echo "Running every ${interval} seconds: >>> $@ <<<"
    echo

    while true; do
        bash ~/.bash/spinner "$@"
        sleep "$interval"
    done
}

# Find a file with a pattern in name:
function ff ()
{
    find . -type f -iname '*'"$*"'*' -ls ;
}

function mysql_import() {
    if [ $# -ne 2 ]; then
        echo "Usage: mysql_import <database_name> <file>"
        return 1
    fi

    username="helios"
    password="helios"
    database=$1
    file=$2

    # Check if the database exists, if not create it
    run mysql -u $username -p$password -e "CREATE DATABASE IF NOT EXISTS $database CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;"

    # Import the database
    run mysql -u $username -p$password $database < $file
}

function service_down () {
	echo
	echo "-------------------------"
	echo "Running: >>> service stop"
	echo
	sudo echo 1 > /dev/null
	nullrun sudo service nginx stop
	nullrun sudo service mysqld stop
	nullrun sudo service redis stop
	nullrun sudo service php7.2-fpm stop
	nullrun sudo service elasticsearch stop
	nullrun sudo service kibana stop
}

function vpn() {
	CONFIG=~/OFFICE_VPN/sslvpn-deep.panara-client-config.ovpn
	PASS=~/OFFICE_VPN/pass.txt
	bash ~/.bash/spinner_with_log sudo -S openvpn --config "$CONFIG" --tun-mtu 1240 --auth-user-pass "$PASS"
}

function sqlmode() {
    # Database connection details
    local HOST="localhost"
    local USER="helios"
    local PASSWORD="helios"
    local DATABASE="${DATABASE:-}"  # optional, or set a default DB if needed

    export MYSQL_PWD="$PASSWORD"

    if echo "SET GLOBAL sql_mode = 'NO_ENGINE_SUBSTITUTION';" | mysql -h "$HOST" -u "$USER" "$DATABASE" 2>/dev/null; then
        echo "✅ SQL mode updated successfully."
    else
        echo "❌ Failed to update SQL mode." >&2
    fi
}


function dump() {
    echo "Denara#25" | sudo -S bash -c 'echo 1 > /dev/null' 2>/dev/null

    if [[ "$1" == "sql" ]]; then
        title1 "Updating sql..."
        bash ~/.bash/spinner_with_log "php app/console doctrine:schema:update --dump-sql --em=client > sql.sql"
        bash ~/.bash/spinner_with_log "bash ~/OneDrive/Importent\\ Data/scripts/run_sql_by_line.sh"

    elif [[ "$1" == "js" ]]; then
        title1 "Updating js..."
        bash ~/.bash/spinner_with_log "sudo chmod -R 777 app/cache/ app/logs/ web/uploads/"
        bash ~/.bash/spinner_with_log "php app/console assets:install"
        bash ~/.bash/spinner_with_log "php app/console assetic:dump"
        bash ~/.bash/spinner_with_log "sudo chmod -R 777 app/cache/ app/logs/ web/uploads/"

    else
        current_php=$(php -r "echo PHP_VERSION;")
        if [[ "$current_php" != 5.6* ]]; then
            title1 "Switching to PHP 5.6..."
            echo "Denara#25" | sudo -S update-alternatives --set php /usr/bin/php5.6
        fi

        title1 "Updating SQL..."
        bash ~/.bash/spinner_with_log "php app/console doctrine:schema:update --dump-sql --em=client > sql.sql"
        bash ~/.bash/spinner_with_log "bash ~/OneDrive/Importent\\ Data/scripts/run_sql_by_line.sh"

        title1 "Updating cache..."
        # bash ~/.bash/spinner_with_log "sudo rm -rf app/cache/* web/js/compiled/"
        bash ~/.bash/spinner_with_log "sudo rm -rf web/js/compiled/"
        bash ~/.bash/spinner_with_log "sudo chmod -R 777 app/cache/ app/logs/ web/uploads/"
        bash ~/.bash/spinner_with_log "php app/console cache:warmup"
        bash ~/.bash/spinner_with_log "php app/console assets:install"
        bash ~/.bash/spinner_with_log "php app/console assetic:dump"
        bash ~/.bash/spinner_with_log "sudo chmod -R 777 app/cache/ app/logs/ web/uploads/"
    fi
}
function localq() {
    
    run bash /home/deep.panara@hs.local/OneDrive/Importent\ Data/scripts/localstack.bash

}

function processXXX() {
    cmd="$1"
    declare -a last_lines=()

    for _ in {1..5}; do echo; done

    $cmd 2>&1 | while IFS= read -r line; do
        last_lines+=("$line")
        (( ${#last_lines[@]} > 5 )) && last_lines=("${last_lines[@]:1}")

        tput cuu 5
        for ((i=0; i<5; i++)); do
            if [[ $i -lt ${#last_lines[@]} ]]; then
                printf "\r\033[K%s\n" "${last_lines[$i]}"
            else
                printf "\r\033[K\n"
            fi
        done
    done

    # --- cleanup after command completes ---
    tput cuu 5
    for ((i=0; i<5; i++)); do
        printf "\r\033[K\n"
    done
}


function qcount() {
    queues=(
        "local-duell-main"
        "local-duell-import"
        "local-duell-manual"
        "duell-daily-cron"
        "duell-daily-cron.fifo"
    )

    fetch_count() {
        queue=$1
        count=$(awslocal sqs get-queue-attributes \
            --queue-url "http://sqs.us-east-1.localhost.localstack.cloud:4566/000000000000/$queue" \
            --attribute-names ApproximateNumberOfMessages \
            --query 'Attributes.ApproximateNumberOfMessages' \
            --output text 2>/dev/null)
        [[ $? -ne 0 || -z "$count" ]] && count="ERR"
        echo "$queue:$count"
    }

    print_header() {
        echo "+----------------------+---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+"
        printf "| %-20s " "Time"
        for q in "${queues[@]}"; do
            printf "| %-25s " "$q"
        done
        echo "|"
        echo "+----------------------+---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+"
    }

    export -f fetch_count

    declare -a last_rows=()

    # print header once
    print_header

    # reserve 12 lines
    for _ in {1..10}; do echo; done

    while true; do
        declare -A counts
        results=$(parallel fetch_count ::: "${queues[@]}")

        timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        line=$(printf "| %-20s " "$timestamp")

        while IFS=":" read -r key val; do
            counts["$key"]="$val"
        done <<< "$results"

        for q in "${queues[@]}"; do
            line+=$(printf "| %-25s " "${counts[$q]}")
        done
        line+="|"

        sep="+----------------------+---------------------------+---------------------------+---------------------------+---------------------------+---------------------------+"

        last_rows+=("$line" "$sep")
        (( ${#last_rows[@]} > 10 )) && last_rows=("${last_rows[@]:2}")

        # move cursor up 12 lines (back into reserved area)
        tput cuu 10

        # redraw 12 lines (pad if fewer)
        for ((i=0; i<10; i++)); do
            if [[ $i -lt ${#last_rows[@]} ]]; then
                printf "%s\n" "${last_rows[$i]}"
            else
                printf "%*s\n" 149 " "  # blank line, table width
            fi
        done

        sleep 1
    done
}


function ext {
    if [ -z "$1" ]; then
        # display usage if no parameters given
        echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
        echo "       extract <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
        return 1
    else
        for n in $@
            do
                if [ -f "$n" ] ; then
                  case "${n%,}" in
                    *.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar)
                                 run tar xvf "$n"       ;;
                    *.lzma)      run unlzma ./"$n"      ;;
                    *.bz2)       run bunzip2 ./"$n"     ;;
                    *.rar)       run unrar x -ad ./"$n" ;;
                    *.gz)        run gunzip ./"$n"      ;;
                    *.zip)       run unzip ./"$n"       ;;
                    *.z)         run uncompress ./"$n"  ;;
                    *.7z|*.arj|*.cab|*.chm|*.deb|*.dmg|*.iso|*.lzh|*.msi|*.rpm|*.udf|*.wim|*.xar)
                                 run 7z x ./"$n"        ;;
                    *.xz)        run unxz ./"$n"        ;;
                    *.exe)       run cabextract ./"$n"  ;;
                    *)
                                 echo "extract: '$n' - unknown archive method"
                                 return 1
                                 ;;
                  esac
                else
                  echo "'$n' - file does not exist"
                  return 1
                fi
            done
    fi
}


if [ -n "$BASH_VERSION" ]; then
    export -f line1 line2 line3 title1 run run0 nullrun loop
elif [ -n "$ZSH_VERSION" ]; then
    # Export only functions that exist
    for fn in line1 line2 line3 title1 run run0 nullrun loop; do
        if functions "$fn" >/dev/null 2>&1; then
            typeset -fx "$fn" 2>/dev/null || true
        fi
    done
fi